## 테스트 시작하기

테스트란?
- 작성된 코드가 의도한 대로 정확하게 동작하는지 확인하는 과정

테스트가 당신의 코드에 미치는 영향
- 사려깊은 설계가 가능해진다.
   · 해당 코드의 API가 잘 설계 되었는지를 시험하는 행위이다.
        ? API란, Application Programming Interface. 응용프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 의미.
   · 코딩전에 테스트를 작성하다 보면 원하는 기능을 추가하기 위해 무엇이 필요한지 고민해보게 된다.
   · 구현보다 인터페이스에 집중하게 된다는 장점도 있다.
- 자신있게 변경할 수 있고, 디버깅 시간이 줄어들고 빠르게 배포할 수 있다.
   · 테스트를 거친 후 서브밋 되는 코드는 통상적으로 결함이 적다.
- 좋은 문서자료가 된다.
   · 한번에 하나의 행위만 집중해서 검증하는 테스트는 문서와 동일한 역할을 한다.
   · 해당 테스트를 읽음으로서 문서를 읽는 것처럼 해당 기능의 동작을 명확하게 이해할 수 있게 된다.
- 작동하는지 검증하는 시간을 줄여준다.
   · 코드를 검사해주는 테스트가 준비되어 있다면 리뷰단계에서 해당 시간을 아낄 수 있다.

올바른 테스트 작성을 위한 규칙
- 인터페이스를 기준으로 테스트를 작성하자.
   · 외부에 노출되는 public메서드를 기준으로 작성
   · 컴포넌트에 대한 단위/통합테스트의 경우 구현 세부명세를 테스트하기보다는, UI구성 요소를 사용자가 사용하는 방식으로 테스트하는게 좋다.
      (사용자가 앱을 사용하는 방식과 테스트가 유사할수록 테스트의 신뢰성은 향상된다.)
- 커버리지보다는 의미있는 테스트인지 고민하자.
   · 아주 간단한 함수는 다른 모듈이나 컴포넌트의 로직에 포함되어 있을때 한번에 검증하는 것이 효율적
- 테스트 코드도 가독성을 높여야 한다.
   · 명확한 테스트 디스크립션이 있다면 테스트파일만 보고 앱이 어떻게 동작하는지 파악하기 좋음
- 하나의 테스트에서는 가급적 하나의 동작만 검증하는 것이 좋다.
   · 하나의 테스트에서 한번에 검증하는 것이 아니라 여러개로 나누어 검증하는것이 가독성과 유지보수에 좋음

테스트 작성하기
- 일반적인 테스트 작성방식
   · AAA(Arrange-Act-Assert)패턴
   · GWT(Given-When-Then)패턴
    1. 테스트를 위한 환경 만들기
    2. 테스트 동작 재현
    3. 올바른 동작이 실행되었는지 또는 변경사항을 검증하기

* 참고자료
AAA(Arrange-Act-Assert)패턴
https://automationpanda.com/2020/07/07/arrange-act-assert-a-pattern-for-writing-good-tests/
링크의 내용은 **"Arrange-Act-Assert" (AAA) 패턴**을 사용하여 좋은 테스트를 작성하는 방법에 대해 설명하고 있습니다. 아래는 주요 내용의 요약입니다:

### Arrange-Act-Assert (AAA) 패턴

   **1. 개요:**
      - Arrange-Act-Assert는 테스트를 명확하고 읽기 쉽게 만드는 구조적 접근 방식입니다. 이 패턴은 테스트 코드의 세 가지 주요 부분을 정의하여, 테스트를 더 이해하기 쉽게 하고 유지보수를 용이하게 합니다.

   **2. 구성 요소:**
      - **Arrange (준비)**: 테스트를 실행하기 위한 사전 조건을 설정합니다. 테스트가 실행될 환경을 구성하고, 필요한 데이터나 상태를 설정합니다.
      - **Act (행동)**: 실제로 테스트할 동작이나 함수를 실행합니다. 이 단계는 테스트의 핵심 작업을 수행합니다.
      - **Assert (검증)**: 테스트 결과를 검증합니다. 예상되는 결과와 실제 결과를 비교하여 테스트가 성공했는지 확인합니다.

   **3. 예시:**
      - **Arrange**: 사용자가 로그인 페이지에 있으며, 올바른 사용자 이름과 비밀번호를 입력할 준비가 되어 있다.
      - **Act**: 로그인 버튼을 클릭한다.
      - **Assert**: 사용자가 대시보드 페이지로 리디렉션되는지 확인한다.

   **4. 장점:**
      - **명확성**: 테스트 코드가 각 단계로 나뉘어 있어, 무엇을 준비하고, 무엇을 실행하며, 무엇을 검증하는지 쉽게 이해할 수 있습니다.
      - **유지보수성**: 테스트 코드의 구조가 일관되어 있어, 새로운 테스트를 추가하거나 기존 테스트를 수정하는 것이 더 간단해집니다.
      - **디버깅**: 테스트가 실패할 경우, 어떤 단계에서 문제가 발생했는지 쉽게 파악할 수 있습니다.

   **5. 적용 방법:**
      - Arrange-Act-Assert 패턴은 다양한 프로그래밍 언어와 테스트 프레임워크에서 사용할 수 있습니다. 이 패턴은 단위 테스트, 통합 테스트 등 여러 종류의 테스트에 적용 가능합니다.
      - **Arrange** 단계에서의 데이터 준비와 환경 설정을 명확히 하고, **Act** 단계에서의 행동을 직관적으로 작성하며, **Assert** 단계에서의 결과 검증을 확실하게 수행하는 것이 중요합니다.

   **6. 결론:**
      - AAA 패턴은 테스트를 작성하는 데 있어 구조적이고 체계적인 접근을 제공하여, 더 나은 품질의 테스트 코드를 작성하고 유지보수하는 데 도움을 줍니다. 

   이 패턴을 활용하면, 테스트의 각 부분을 명확하게 나누어 작성할 수 있어, 코드의 가독성 및 유지보수성이 향상됩니다.

GWT(Given-When-Then)패턴

링크의 내용은 Martin Fowler의 "Given-When-Then" 패턴에 관한 것입니다. 이 패턴은 주로 행동 주도 개발(Behavior-Driven Development, BDD)에서 사용됩니다. 아래는 주요 내용을 요약한 것입니다:

### Given-When-Then 패턴
https://martinfowler.com/bliki/GivenWhenThen.html
   **1. 개요:**
      - Given-When-Then 패턴은 시스템의 행동을 정의하고 테스트하는 데 도움이 되는 구조적 접근 방식입니다. 이 패턴은 테스트를 읽기 쉽고 이해하기 쉽게 만들어줍니다.

   **2. 구성 요소:**
      - **Given**: 특정 상황이나 상태를 설정합니다. 이 단계는 테스트가 시작되기 전에 필요한 사전 조건을 정의합니다.
      - **When**: 특정 행동이나 사건을 설명합니다. 이 단계는 테스트할 동작을 실행하는 부분입니다.
      - **Then**: 기대되는 결과나 상태를 설명합니다. 이 단계는 행동의 결과가 예상과 일치하는지 확인합니다.

   **3. 예시:**
      - **Given**: 사용자가 로그인 페이지에 있다.
      - **When**: 올바른 자격 증명을 입력하고 로그인 버튼을 클릭한다.
      - **Then**: 사용자는 대시보드 페이지로 리디렉션된다.

   **4. 장점:**
      - **명확성**: 각 테스트 케이스가 쉽게 이해되며, 비즈니스 요구 사항과 일치하는지 검토하기 쉽습니다.
      - **커뮤니케이션**: 비즈니스 분석가, 개발자, 테스트 담당자 간의 의사소통을 개선합니다.
      - **재사용성**: 같은 "Given" 상태를 다양한 "When" 및 "Then" 조합으로 재사용할 수 있습니다.

   **5. 적용 방법:**
      - Given-When-Then 패턴은 주로 BDD 프레임워크에서 사용되며, 자동화된 테스트를 작성하는 데 유용합니다. 이 패턴을 사용하면 테스트가 보다 구체적이고, 비즈니스 요구 사항과 직접적으로 연관되게 됩니다.

   이 패턴은 테스트의 가독성과 유지 보수성을 높이는 데 도움을 줍니다. Martin Fowler는 이 방법을 통해 개발자와 비즈니스 이해관계자 간의 협업을 증진시키고, 명확한 요구 사항을 기반으로 하는 테스트를 작성할 수 있다고 강조합니다.

--------------------------------------------------------------------
## 프런트엔드 테스트 종류
기능테스트
- 요구사항에서 누락된 부분, 오류가 있는 부분, 또는 생략된 부분을 찾는 것
   === 앱의 기능이 요구사항대로 잘 동작하는지를 검증하는 테스트를 의미한다.
- 기능테스트 : 개별 기능에 초점을 맞추며 각 기능이 요구사항에 부합하는지 확인
- 비기능테스트 : 요구사항보다 소프트웨어가 얼마다 잘 동작하는지를 측정
- 프론트엔드에서 가장 많이 사용하는 기능 테스트의 구현형태
   · 컴포넌트의 이벤트 트리거 시 목적에 맞게 동작하는지
   · 분기별로 렌더링 되어야 하는 컴포넌트가 제대로 보여지고 있는지
   · 함수의 결과가 의도한 대로 동작하는지 등을 검증

단위테스트
- 함수나 메서드 등을 독립적으로 검증하는 과정
   · 단일컴포넌트(클래스)의 상태관리에 대한 함수 등이 단위 테스트의 대상이 되기도 함
   · 상호작용을 검증하기보단 각 행위를 독립적으로 검증
   · 협업 환경에서 주로 공통 컴포넌트 또는 공통 유틸, 헬퍼 함수가 테스트의 대상이 된다.
- 단위테스트 하기에 적합한 모듈
   · 다른 모듈에 대한 의존성이 거의 없고, 해당 모듈 자체만으로 작지만 독립적인 역할을 수행하는 모듈
   · 리액트 훅 또한 리액트 렌더링 매커니즘을 따르는 단순 함수이기 때문에 독립적인 단위 테스트를 작성하기에 적합

통합테스트
- 개별적으로 테스트된 모듈들을 결합하여 그들 사이에 상호작용과 인터페이스 오류의 부재를 검증하는 과정
- 모듈간의 통합 과정에서 발생할 수 있는 오류를 찾아내는 데 중점을 둔다.
- 단위테스트보다 좀더 실제 앱의 비즈니스 로직과 가깝게 겁증할 수 있다.

- 통합테스트 하기에 적합한 모듈
   · 특정 상태를 기준으로 동작하는 컴포넌트 조합 및 API와 함께 상호작용하는 컴포넌트 조합이 대상이 됨
   · 상태나 데이터를 관리하는 특정 컴포넌트를 기준으로 하위 컴포넌트가 제대로 렌더링되는지(혹은 동작하는지)를 검증
- 통합테스트 시 중요한점
   · 가능한 한 모킹을 하지 않고 실제와 유사하게 검증해야함
   · 어쩔 수 없이 모킹이 필요한 순간들의 경우 API의 응답 같은 것은 msw같은 도구를 활용하면 여러 케이스를 쉽게 검증할 수 있음
      ** msw란?
         Mock Service Worker로 서비스 워커를 이용하여 API를 모킹하는 라이브러리입니다. 
         네트워크 요청을 가로채도록 설계된 Service Worker API를 활용하기 때문에 목 사용 여부 관계 없이 동일한 애플리케이션 동작을 보장합니다. 
         또한, 모킹을 위해 애플리케이션 코드를 변경할 필요가 없습니다.
         https://blog.mathpresso.com/msw%EB%A1%9C-api-%EB%AA%A8%ED%82%B9%ED%95%98%EA%B8%B0-2d8a803c3d5c

- 통합테스트는 비즈니스로직을 나누어 컴포넌트의 상호작용을 검증하는 데에 매우 효율적이다.
- 단점은 모킹에 의존하다보니 전체 워크 플로우를 검증하기에는 무리가 있다.

E2E테스트(End-to-End테스트)
- 사용자의 관점에서 소프트웨어의 전체시스템을 테스트하는 과정을 말함.
- 이 테스트는 사용자의 실제 사용사례를 모방하여 소프트웨어의 모든 구성요소와 그 상호작용이 의도한 대로 작동하는지 확인.
- 사용자 인터페이스 / 데이터베이스 / 네트워크 / 외부 시스템 및 서비스 등 소프트웨어의 모든 계층을 포함.

- 완성된 앱을 실행해 전체 소프트웨어 시스템의 전체 흐름을 검증
- 사용자가 앱을 사용하는 다양한 시나리오가 실제 환경에서 정상적으로 작동하는지 검증.
- API를 포함한 모든 워크플로우를 검증하는 것이 핵심
- 다만, 실패 케이스 등을 검증하거나 백엔드와 협의가 어려운 경우 일부 모킹을 통해 검증하는 것도 의미 있음.
- 테스트를 위한 별도 DB나 검증용 계정이나 처리가 필요할 수 있고, 다른 환경을 구성하는 경우도 많음.

- E2E테스트의 실행속도는 단테나 통테에 비해 테스트 실행속도가 훨씬 느림
- 실행 시간이 길다는 것은 피드백을 받아 수정하는 시간도 증가한다는 의미로 생산성의 저하로 이어짐
- 복잡한 소프트웨어 계층과 하드웨어 결함까지 영향을 받을 수 있어 결정성 보장이 어려움
   · 일관적으로 동작해야 한다는 결정성은 테스트의 신뢰에 영향을 주는 요소
- 외부환경에 의해 테스트가 쉽게 실패할 수 있어 관리비용이 꽤 큰 테스트

UI테스트와 회귀 테스트
- 단테,통테,E2E테스트는 주로 앱의 기능에 대한 검증을 진행하지만 FE영역에서는 제대로 렌더링이 되었는지 시각적인 부분도 검증이 필요.
- 스냅샷 테스트 / 시각적 회귀 테스트
- 소프트웨어 테스트 분야에서 회귀(Regression)는 새로운 변경사항이 기존의 시스템이나 기능에 영향을 주어 발생할 수 있는 문제를 찾아내는 과정을 의미
- UI테스트에서 회귀테스트는 소프트웨어의 시각적 요소가 변경 전후로 일관되게 유지되는지 확인하는 테스트 방법 
         ↓────────────────────────────────────────────────────┐
   기준이 되는UI → 변경탐지 → 개발자가 의도한 방향인가? ┬ Y : 기준UI업데이트
                                                    └ N : 버그 수정
- 회귀 테스트를 진행하기 위해서는 비교하기 위한 렌더링 결과가 실체화 된 형태로 있어야 함
- 이런 렌더링 결과를 보통 스탭샷이라고 하고, 컴포넌트의 DOM구조를 직렬화 하여 객체 형태로 기록하거나 이미지 형태로 기록하는것을 의미

스냅샷 테스트
- 일반적인 스냅샷 테스트는 jsDOM을 사용한 스냅샷 테스트를 의미함
   ** jsDOM이란?
      HTML의 DOM구조를 직렬화하여 기록하고, 이전에 기록한 스냅샷과 비교하여 검증.
      리액트에서 Virtual DOM을 활용하기 때문에 렌더링 된 가상의 DOM 객체가 스냅샷 테스트의 대상이 되기도 한다.
      https://www.testim.io/blog/jsdom-a-guide-to-how-to-get-started-and-what-you-can-do/
💡 · 스냅샷 테스트의 과정
      1. 대상 컴포넌트를 렌더링 합니다.
      2. 컴포넌트의 **DOM을 직렬화**해 스냅샷으로 기록합니다.
      3. 기존의 스냅샷과 새로운 스냅샷을 비교합니다. (비교할 스냅샷이 없다면 현재 스냅샷을 기록합니다.)
      4. 기존 스냅샷과 현재 **스냅샷이 동일한 경우 테스트는 통과**합니다.
      5. 기존 스냅샷과 현재 **스냅샷이 다르다면 변경 사항을 확인**합니다.
         1. 5-1. 의도한 변경일 경우 스냅샷을 업데이트 합니다.
         2. 5-2. 의도한 변경이 아닐 경우 잘못된 부분을 찾아 수정합니다.
- 생각보다 관리하기 어려운 테스트이다.
- 복잡한 컴포넌트의 경우 스냅샷 결과만 30-40줄을 넘어가는 경우도 많다.
- 가독성이 좋지 않고, 결과만 봤을때 실제로 어떻게 렌더링 될지는 알기 어렵다.
- 스냅샷 업데이트가 많은 경우 UI변경사항을 추적하기 어렵고, 자동화툴을 사용할 경우 테스트에대한 제대로 된 고찰 없이 무의미하게 업데이트를 칠 수도 있음.

시각적 회귀 테스트
- 시각적 요소가 변경되지 않았는지 확인하는 테스트
- 픽셀단위의 비교도 가능하지만 같은 이미지도 렌더링된 방식에 따라 다른 이미지로 판단되는 경우도 있음
- 비용과 관리에 대한 부담이 크다.
   · 소스는 오픈되어 있으나 운영의 어려움을 타깃하여 클라우드로 서비스를 제공하는 경우도 있음
- 테스트가 실패했을 경우 원인을 명확하게 찾기 힘들다는 단점이 있음

스토리북
- 프론트엔드 개발에서 시각적 회귀 테스트를 이야기 할 때 스토리 북에 대한 이야기를 빼고 이야기하기 어렵다.
   · 현대의 프론트엔드 개발로 들어서 면서 컴포넌트 기반의 설계철학이 보편적으로 자리 잡았습니다. 
   · 그리고 개발자들은 각 컴포넌트 별로 UI를 확인하고 다양한 상황에 맞게 스타일이 변경 되는지 편하게 확인할 수 있는 도구가 필요 했습니다.
   · 스토리북 작성을 통해 개발 과정에서 실제 UI를 눈으로 확인 하면서 개발을 할 수 있게 되었다.
   · 일반적인 간단한 컴포넌트는 별도의 테스트 코드 없이 스토리북으로 관리할 수 있다.
   · 컴포넌트의 업데이트를 관리하기 위해 스토리북과 연계된 시각적 회귀 테스트 도구를 활용해 작성하는 경우가 많다. 
   · 시각적 회귀 테스트를 작성할 때 꼭 스토리북이 필요한 것은 아니지만, 함께 사용할 때 강력합니다.
   · Chromatic, Applitools, Percy, BackstopJS 등등이 있으며, 별도 클라우드와 엮어 스토리북에서 제공하는 addon을 사용해 코드를 작성할 수도 있다. 

마치며
- 모든테스트는 목적이 있고, 한계가 명확함.
- 현재 진행하고 있는 프로젝트에 맞는 테스트를 선택해 전략을 짜고 가장 저렴한 방법으로 큰 효율을 누릴 수 있는 전략을 고민해보시길 바람.

단테/통테
jest: https://jestjs.io/
vite: https://vitest.dev/
react testing library: https://testing-library.com/docs/react-testing-library/intro/

E2E테스트
cypress: https://www.cypress.io/
playwright: https://playwright.dev/
puppeteer: https://pptr.dev/

스냅샷 테스트
jest: https://jestjs.io/
vitest: https://vitest.dev/guide/snapshot

시각적 회귀 테스트
chromatic: https://www.chromatic.com/storybook
chromatic: https://www.chromatic.com/
GitHub-garris/BackstopJs: https://github.com/garris/BackstopJS
applitools: https://applitools.com/